<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Matside — Control Panel v4.3</title>

<!-- Firebase for match feed -->
<script src="https://www.gstatic.com/firebasejs/10.13.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.13.1/firebase-firestore-compat.js"></script>

<style>
  :root {
    --bg: #05060a;
    --panel: #11131b;
    --panel-soft: #141824;
    --muted: #9aa0a6;
    --accent: #1e88e5;
    --accent-soft: rgba(30,136,229,0.22);
    --red: #d32f2f;
    --green: #43a047;
    --danger: #f44336;
    --good: #4caf50;
    --outline: rgba(255,255,255,0.04);
    --outline-strong: rgba(255,255,255,0.12);
    --shadow-soft: 0 18px 45px rgba(0,0,0,0.65);
  }

  * {
    box-sizing: border-box;
  }

  body {
    margin: 0;
    padding: 16px 16px 28px;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif;
    background: radial-gradient(circle at top, #151829 0, #05060a 42%, #020308 100%);
    color: #e9eaee;
  }

  .wrap {
    max-width: 1120px;
    margin: 0 auto;
  }

  /* HEADER BAR */

  .header-bar {
    max-width: 1120px;
    margin: 0 auto 14px;
    padding: 10px 14px;
    border-radius: 14px;
    background:
      linear-gradient(135deg, rgba(25,118,210,0.18), rgba(2,3,8,0.96));
    border: 1px solid rgba(120,172,255,0.35);
    box-shadow: 0 18px 45px rgba(0,0,0,0.7);
    display: flex;
    align-items: center;
    justify-content: space-between;
  }

  .header-inner {
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .brand-logo {
    width: 44px;
    height: 44px;
    border-radius: 12px;
    background: #02030a;
    object-fit: contain;
    padding: 4px;
    border: 1px solid rgba(255,255,255,0.08);
  }

  .brand-title {
    font-size: 18px;
    font-weight: 650;
    letter-spacing: 0.03em;
  }

  .header-accent {
    font-size: 12px;
    color: rgba(255,255,255,0.72);
  }

  .header-accent span {
    opacity: 0.7;
  }

  .header-accent strong {
    font-weight: 600;
  }

  /* TOP ROW */

  .top-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 10px;
    margin: 12px 0;
  }

  .brand-mini {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .brand-mini img {
    width: 32px;
    height: 32px;
    border-radius: 8px;
    border: 1px solid rgba(255,255,255,0.1);
    background: #02030a;
    object-fit: contain;
    padding: 3px;
  }

  .brand-mini-text {
    display: flex;
    flex-direction: column;
    gap: 1px;
  }

  .brand-mini-text span:first-child {
    font-size: 13px;
    text-transform: uppercase;
    letter-spacing: 0.18em;
    color: var(--muted);
  }

  .brand-mini-text span:last-child {
    font-size: 12px;
    color: rgba(255,255,255,0.7);
  }

  .top-right {
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .conn-pill {
    padding: 5px 9px;
    border-radius: 999px;
    font-size: 11px;
    display: inline-flex;
    align-items: center;
    gap: 6px;
    border: 1px solid rgba(255,255,255,0.16);
    background: radial-gradient(circle at top left,#30344b,#141624);
  }

  .conn-dot {
    width: 7px;
    height: 7px;
    border-radius: 999px;
    background: #f44336;
  }

  .conn-pill.connected .conn-dot {
    background: #4caf50;
  }

  .conn-label {
    text-transform: uppercase;
    letter-spacing: 0.16em;
    font-size: 10px;
    color: var(--muted);
  }

  .conn-state {
    font-size: 11px;
    font-weight: 600;
  }

  .mat-select-wrap {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 4px 8px;
    border-radius: 999px;
    border: 1px solid rgba(255,255,255,0.16);
    background: #0b0d15;
  }

  .mat-select-wrap label {
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.18em;
    color: var(--muted);
  }

  .mat-select-wrap select {
    background: #151829;
    border-radius: 999px;
    border: 1px solid rgba(255,255,255,0.18);
    color: #fff;
    font-size: 12px;
    padding: 3px 9px;
  }

  /* UPCOMING MATCH CARD */

  .upcoming-card {
    margin: 10px auto 14px;
    max-width: 1100px;
    padding: 10px 14px;
    border-radius: 14px;
    background: radial-gradient(circle at top left,
      rgba(30,136,229,0.12),
      rgba(5,6,10,0.96));
    border: 1px solid rgba(255,255,255,0.06);
    display: grid;
    grid-template-columns: repeat(4,minmax(0,1fr));
    gap: 8px 16px;
    align-items: center;
    font-size: 13px;
  }

  .upcoming-title {
    grid-column: 1 / -1;
    font-size: 12px;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    color: var(--muted);
    margin-bottom: 2px;
  }

  .up-line {
    display: flex;
    gap: 6px;
    align-items: baseline;
  }

  .up-label {
    color: var(--muted);
    font-size: 12px;
    min-width: 70px;
  }

  .up-value {
    font-weight: 600;
    color: #fff;
    font-size: 13px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .up-queue .up-value {
    opacity: 0.85;
  }

  @media (max-width: 900px) {
    .upcoming-card {
      grid-template-columns: repeat(2,minmax(0,1fr));
    }
  }

  @media (max-width: 600px) {
    .upcoming-card {
      grid-template-columns: minmax(0,1fr);
    }
  }

  /* FULL-WIDTH SCORING CARD */

  .card {
    background: #10121d;
    border-radius: 18px;
    padding: 14px 14px 16px;
    box-shadow: var(--shadow-soft);
    border: 1px solid var(--outline);
  }

  .card h3 {
    margin: 0 0 4px;
    font-size: 15px;
    font-weight: 600;
  }

  .card-sub {
    font-size: 12px;
    color: var(--muted);
    margin-bottom: 10px;
  }

  .score-card-full {
    max-width: 1100px;
    margin: 0 auto 14px;
  }

  .score-row {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
  }

  @media (max-width: 720px) {
    .score-row {
      grid-template-columns: 1fr;
    }
  }

  .score-box {
    border-radius: 16px;
    padding: 12px 12px 10px;
    border: 1px solid var(--outline);
    background: radial-gradient(circle at top, rgba(211,47,47,0.18), #11131b);
  }

  .score-box.green-side {
    background: radial-gradient(circle at top, rgba(67,160,71,0.18), #11131b);
  }

  .score-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 6px;
  }

  .score-header span {
    font-size: 11px;
    letter-spacing: 0.18em;
    text-transform: uppercase;
    color: var(--muted);
  }

  .score-header strong {
    font-size: 13px;
    font-weight: 600;
  }

  .big-score {
    font-size: 32px;
    font-weight: 700;
    margin: 2px 0 8px;
  }

  .score-name-input {
    width: 100%;
    padding: 6px 8px;
    border-radius: 10px;
    border: 1px solid rgba(255,255,255,0.08);
    background: #050711;
    color: #fff;
    font-size: 12px;
    margin-bottom: 6px;
  }

  .score-name-input::placeholder {
    color: rgba(255,255,255,0.35);
  }

  .score-buttons {
    display: grid;
    grid-template-columns: repeat(4, minmax(0,1fr));
    gap: 6px;
    margin-top: 4px;
  }

  @media (max-width: 720px) {
    .score-buttons {
      grid-template-columns: repeat(2,minmax(0,1fr));
    }
  }

  /* GRID */

  .grid {
    display: grid;
    grid-template-columns: minmax(0,1.3fr) minmax(0,1.1fr);
    gap: 14px;
    max-width: 1100px;
    margin: 0 auto;
  }

  @media (max-width: 880px) {
    .grid {
      grid-template-columns: minmax(0,1fr);
    }
  }

  .section-label {
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.18em;
    color: var(--muted);
    margin-bottom: 4px;
  }

  /* TIMER LAYOUT */

  .timer-layout {
    display: grid;
    grid-template-columns: 1.2fr 1fr;
    gap: 12px;
  }

  @media (max-width: 720px) {
    .timer-layout {
      grid-template-columns: 1fr;
    }
  }

  .timer-row-main {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .timer-button-group {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
  }

  .scoreline {
    display: flex;
    align-items: baseline;
    gap: 12px;
    font-variant-numeric: tabular-nums;
  }

  .scoreline label {
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.18em;
    color: var(--muted);
  }

  .scoreline span {
    font-size: 20px;
    font-weight: 650;
  }

  .scoreline .sep {
    width: 1px;
    height: 18px;
    background: rgba(255,255,255,0.16);
  }

  .timer-controls {
    display: flex;
    gap: 6px;
    flex-wrap: wrap;
  }

  .timer-controls button {
    flex: 1 0 80px;
  }

  .segment-row {
    display: flex;
    gap: 8px;
    align-items: center;
    flex-wrap: wrap;
    margin-top: 6px;
  }

  .seg-pill {
    padding: 4px 9px;
    border-radius: 999px;
    border: 1px solid rgba(255,255,255,0.14);
    font-size: 11px;
    background: #080a10;
    color: #e9eaee;
    cursor: pointer;
  }

  .seg-pill.active {
    background: var(--accent-soft);
    border-color: rgba(94,166,255,0.85);
  }

  .seg-pill span {
    opacity: 0.86;
  }

  .toggle-row {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-top: 8px;
    font-size: 12px;
  }

  .toggle-row input[type="checkbox"] {
    accent-color: var(--accent);
  }

  /* TIMELINE */

  .timeline-card {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .timeline-stream {
    margin-top: 4px;
    border-radius: 12px;
    padding: 8px 10px;
    min-height: 150px;
    max-height: 270px;
    background: #050711;
    border: 1px solid var(--outline);
    overflow-y: auto;
    font-size: 12px;
  }

  .tl-item {
    margin-bottom: 4px;
    display: flex;
    gap: 6px;
    align-items: baseline;
  }

  .tl-time {
    font-size: 10px;
    color: var(--muted);
    letter-spacing: 0.12em;
    text-transform: uppercase;
    min-width: 60px;
  }

  .tl-text {
    font-size: 12px;
  }

  /* LAST MATCH */

  .bottom-row {
    max-width: 1100px;
    margin: 10px auto 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 11px;
    color: var(--muted);
  }

  .bottom-row span strong {
    color: rgba(255,255,255,0.86);
  }

  #version-tag {
    position: fixed;
    bottom: 8px;
    right: 12px;
    font-size: 10px;
    color: rgba(255,255,255,0.3);
  }

  /* BUTTONS */

  .btn {
    border: none;
    border-radius: 999px;
    padding: 7px 12px;
    font-size: 12px;
    font-weight: 600;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    gap: 6px;
    background: #181a26;
    color: #f5f5f5;
    border: 1px solid rgba(255,255,255,0.08);
  }

  .btn-wide {
    min-width: 118px;
    justify-content: center;
  }

  .small {
    padding: 6px 10px;
    font-size: 12px;
  }

  .blue {
    background: linear-gradient(135deg,#2196f3,#1976d2);
    color: #fff;
  }

  .gray {
    background: linear-gradient(135deg,#424242,#212121);
    color: #e0e0e0;
  }

  .red {
    background: linear-gradient(135deg,#ef5350,#c62828);
    color: #fff;
  }

  .outline {
    background: transparent;
  }

  .btn:disabled {
    opacity: 0.35;
    cursor: default;
  }

  .chip {
    border-radius: 999px;
    padding: 4px 8px;
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.14em;
    border: 1px solid rgba(255,255,255,0.1);
    color: var(--muted);
  }

  /* MATCH MODAL */

  #matchModalBackdrop {
    position: fixed;
    inset: 0;
    background: rgba(10,10,20,0.75);
    backdrop-filter: blur(8px);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 40;
  }

  #matchModalBackdrop.show {
    display: flex;
  }

  .modal {
    width: 360px;
    max-width: 90vw;
    background: #10121d;
    border-radius: 18px;
    padding: 16px 16px 14px;
    box-shadow: 0 22px 55px rgba(0,0,0,0.8);
    border: 1px solid rgba(255,255,255,0.12);
  }

  .modal h3 {
    margin: 0 0 8px;
    font-size: 16px;
  }

  .modal-section {
    margin-bottom: 10px;
  }

  .pill-row {
    display: flex;
    gap: 6px;
    margin-top: 6px;
  }

  .pill-btn-fat {
    flex: 1;
    border-radius: 999px;
    padding: 7px 10px;
    font-size: 12px;
    border: 1px solid rgba(255,255,255,0.14);
    background: #181a26;
    color: #fff;
    cursor: pointer;
  }

  .pill-btn-fat.active {
    background: var(--accent-soft);
    border-color: rgba(94,166,255,0.9);
  }

  .method-grid {
    display: grid;
    grid-template-columns: repeat(2,minmax(0,1fr));
    gap: 6px;
    margin-top: 6px;
  }

  /* TOAST */

  #toast {
    position: fixed;
    left: 50%;
    bottom: 18px;
    transform: translateX(-50%);
    padding: 7px 13px;
    border-radius: 999px;
    background: rgba(22,24,34,0.92);
    color: #fff;
    font-size: 12px;
    display: flex;
    gap: 6px;
    align-items: center;
    opacity: 0;
    transition: opacity 0.16s ease-out, transform 0.14s ease-out;
    border: 1px solid rgba(255,255,255,0.12);
    z-index: 50;
  }

  #toast.show {
    opacity: 1;
    transform: translateX(-50%) translateY(-2px);
  }

  #toastIcon {
    font-size: 13px;
  }
</style>
</head>

<body>
<div class="header-bar">
  <div class="header-inner">
    <img src="https://www.matside.org/assets/images/image01.png" class="brand-logo" alt="Matside logo"/>
    <div class="brand-title">Matside Control Hub</div>
  </div>
  <div class="header-accent">
    <span>Operator View</span> &nbsp;•&nbsp;
    <strong>Real-time Mat Control</strong>
  </div>
</div>

<div class="wrap">

  <!-- TOP BAR -->
  <div class="top-row">
    <div class="brand-mini">
      <img src="https://www.matside.org/assets/images/image01.png" alt="Matside mini"/>
      <div class="brand-mini-text">
        <span>Matside Systems</span>
        <span>Control, timing, and scoreboard sync in one place.</span>
      </div>
    </div>

    <div class="top-right">
      <div class="conn-pill" id="connPill">
        <div class="conn-dot"></div>
        <div class="conn-label">server</div>
        <div class="conn-state" id="conn">connecting…</div>
      </div>
      <div class="mat-select-wrap">
        <label for="matSelect">Mat</label>
        <select id="matSelect">
          <option value="1">Mat 1</option>
          <option value="2">Mat 2</option>
          <option value="3">Mat 3</option>
          <option value="4">Mat 4</option>
        </select>
      </div>
    </div>
  </div>

  <!-- UPCOMING MATCHES -->
  <div class="upcoming-card">
    <div class="upcoming-title">Upcoming on this Mat</div>
    <div class="up-line"><span class="up-label">Now:</span><span id="upNow" class="up-value">—</span></div>
    <div class="up-line"><span class="up-label">On Deck:</span><span id="upDeck" class="up-value">—</span></div>
    <div class="up-line"><span class="up-label">In The Hole:</span><span id="upHole" class="up-value">—</span></div>
    <div class="up-line up-queue"><span class="up-label">Queue:</span><span id="upQueue" class="up-value">—</span></div>
  </div>

  <!-- FULL-WIDTH SCORING CARD -->
  <div class="card score-card-full">
    <h3>Scoring</h3>
    <div class="card-sub">
      Apply points for takedowns, escapes, reversals, and nearfalls.
    </div>
    <div class="score-row">
      <!-- RED SIDE -->
      <div class="score-box">
        <input id="redNameInput" class="score-name-input" placeholder="Red wrestler name"/>
        <div class="score-header">
          <span>Red wrestler</span>
          <strong id="redNameLabel">Red</strong>
        </div>
        <div class="big-score" id="redScoreDisplay">0</div>
        <div class="score-buttons">
          <button class="btn small" data-score="red" data-pts="3">Takedown +3</button>
          <button class="btn small" data-score="red" data-pts="1">Escape +1</button>
          <button class="btn small" data-score="red" data-pts="2">Reversal +2</button>
          <button class="btn small" data-score="red" data-pts="2">Near Fall +2</button>
          <button class="btn small" data-score="red" data-pts="3">Near Fall +3</button>
          <button class="btn small" data-score="red" data-pts="4">Near Fall +4</button>
          <button class="btn small" data-score="red" data-pts="1">+1</button>
          <button class="btn small" data-score="red" data-pts="-1">-1</button>
        </div>
      </div>

      <!-- GREEN SIDE -->
      <div class="score-box green-side">
        <input id="greenNameInput" class="score-name-input" placeholder="Green wrestler name"/>
        <div class="score-header">
          <span>Green wrestler</span>
          <strong id="greenNameLabel">Green</strong>
        </div>
        <div class="big-score" id="greenScoreDisplay">0</div>
        <div class="score-buttons">
          <button class="btn small" data-score="green" data-pts="3">Takedown +3</button>
          <button class="btn small" data-score="green" data-pts="1">Escape +1</button>
          <button class="btn small" data-score="green" data-pts="2">Reversal +2</button>
          <button class="btn small" data-score="green" data-pts="2">Near Fall +2</button>
          <button class="btn small" data-score="green" data-pts="3">Near Fall +3</button>
          <button class="btn small" data-score="green" data-pts="4">Near Fall +4</button>
          <button class="btn small" data-score="green" data-pts="1">+1</button>
          <button class="btn small" data-score="green" data-pts="-1">-1</button>
        </div>
      </div>
    </div>
  </div>

  <!-- MAIN GRID -->
  <div class="grid">

    <!-- LEFT COLUMN -->
    <div>
      <!-- TIMER CARD -->
      <div class="card">
        <h3>Timer</h3>
        <div class="card-sub">
          Control the clock and choose regulation or overtime segments.
        </div>

        <div class="timer-layout">

          <!-- Start / Stop / End Match -->
          <div class="timer-row-main">
            <div class="timer-button-group">
              <button id="startBtn" class="blue btn-wide">Start</button>
              <button id="stopBtn"  class="gray btn-wide">Stop</button>
              <button id="resetTimerBtn" class="outline btn-wide small">Reset Clock</button>
              <button id="endMatchBtn" class="red btn-wide small">End Match</button>
            </div>

            <div class="scoreline">
              <label>Clock</label>
              <span id="clockDisplay">01:00</span>
              <div class="sep"></div>
              <label>Segment</label>
              <span id="segDisplay">REG1</span>
            </div>

            <div class="segment-row">
              <span class="chip">Segments</span>
              <button class="seg-pill" data-seg="REG1"><span>Reg 1 (1:00)</span></button>
              <button class="seg-pill" data-seg="REG2"><span>Reg 2 (1:30)</span></button>
              <button class="seg-pill" data-seg="REG3"><span>Reg 3 (2:00)</span></button>
              <button class="seg-pill" data-seg="OT"><span>OT (1:00)</span></button>
              <button class="seg-pill" data-seg="TB1"><span>TB1 (0:30)</span></button>
              <button class="seg-pill" data-seg="TB2"><span>TB2 (0:30)</span></button>
              <button class="seg-pill" data-seg="UT"><span>UT (0:30)</span></button>
            </div>

            <div class="toggle-row">
              <input type="checkbox" id="runningToggle"/>
              <label for="runningToggle">Running (toggle instead of Start/Stop)</label>
            </div>
          </div>

          <!-- Extra Controls -->
          <div>
            <div class="section-label">Fine Controls</div>
            <div class="timer-controls">
              <button class="btn small outline" data-jog="-5">-5 sec</button>
              <button class="btn small outline" data-jog="-1">-1 sec</button>
              <button class="btn small outline" data-jog="1">+1 sec</button>
              <button class="btn small outline" data-jog="5">+5 sec</button>
            </div>
          </div>

        </div>
      </div>
    </div>

    <!-- RIGHT COLUMN -->
    <div>
      <!-- TIMELINE CARD -->
      <div class="card timeline-card">
        <h3>Timeline</h3>
        <div class="card-sub">
          Every score change, clock adjustment, and match result is tracked here.
        </div>
        <div id="timelineStream" class="timeline-stream"></div>
      </div>

      <!-- LAST MATCH CARD -->
      <div class="card" style="margin-top:10px;">
        <h3>Last Match</h3>
        <div class="card-sub">
          Snapshot of the previous result on this mat.
        </div>
        <div class="section-label">Result</div>
        <div id="lastMatchMain" style="font-size:13px;font-weight:600;margin-bottom:4px;">—</div>
        <div id="lastMatchMeta" style="font-size:11px;color:var(--muted);">—</div>
      </div>
    </div>

  </div>

  <div class="bottom-row">
    <span>Keyboard hotkeys: <strong>1–5</strong> red score, <strong>7–0</strong> green score, <strong>Space</strong> start/stop, <strong>R</strong> reset clock, <strong>E</strong> end match.</span>
  </div>

</div>

<!-- MATCH MODAL -->
<div id="matchModalBackdrop">
  <div class="modal">
    <h3>End Match</h3>

    <div class="modal-section">
      <h4 style="margin:0 0 4px 0;font-size:13px;">Suggested</h4>
      <div id="suggestLine" class="suggest-line">—</div>
    </div>

    <div class="modal-section">
      <h4 style="margin:0 0 4px 0;font-size:13px;">Winner</h4>
      <div class="pill-row">
        <button id="winnerRedBtn"   class="pill-btn-fat">Red</button>
        <button id="winnerGreenBtn" class="pill-btn-fat">Green</button>
      </div>
    </div>

    <div class="modal-section">
      <h4 style="margin:0 0 4px 0;font-size:13px;">Method</h4>
      <div class="method-grid">
        <button class="pill-btn-fat" data-method="decision">Decision</button>
        <button class="pill-btn-fat" data-method="major_decision">Major Dec</button>
        <button class="pill-btn-fat" data-method="tech_fall">Tech Fall</button>
        <button class="pill-btn-fat" data-method="fall">Fall</button>
      </div>
    </div>

    <div class="pill-row" style="margin-top:12px;">
      <button id="cancelMatchBtn" class="pill-btn-fat">Cancel</button>
      <button id="confirmMatchBtn" class="pill-btn-fat" style="background:#1e88e5;border-color:#64b5f6;">Submit</button>
    </div>
  </div>
</div>

<!-- TOAST -->
<div id="toast">
  <span id="toastIcon">✓</span>
  <span id="toastText">Saved</span>
</div>

<div id="version-tag">v4.3 (Full-width scoring, classic buttons)</div>

<!-- Socket.IO -->
<script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>

<script>
  const SERVER_URL = "https://scoreboard-server-er33.onrender.com";
  const socket = io(SERVER_URL, { transports:["websocket","polling"] });

  let mats = {};
  let currentMat = 1;

  const matSelect   = document.getElementById("matSelect");
  const connEl      = document.getElementById("conn");
  const connPill    = document.getElementById("connPill");

  const timelineStream   = document.getElementById("timelineStream");
  const toastEl          = document.getElementById("toast");
  const toastTextEl      = document.getElementById("toastText");

  const redNameInput     = document.getElementById("redNameInput");
  const greenNameInput   = document.getElementById("greenNameInput");
  const redNameLabel     = document.getElementById("redNameLabel");
  const greenNameLabel   = document.getElementById("greenNameLabel");

  const redScoreDisplay   = document.getElementById("redScoreDisplay");
  const greenScoreDisplay = document.getElementById("greenScoreDisplay");

  const clockDisplay   = document.getElementById("clockDisplay");
  const segDisplay     = document.getElementById("segDisplay");
  const runningToggle  = document.getElementById("runningToggle");

  const lastMatchMainEl  = document.getElementById("lastMatchMain");
  const lastMatchMetaEl  = document.getElementById("lastMatchMeta");

  // Firebase + upcoming match feed
  let db = null;
  let currentEventId = null;
  let unsubscribeMatches = null;

  const upNowEl   = document.getElementById("upNow");
  const upDeckEl  = document.getElementById("upDeck");
  const upHoleEl  = document.getElementById("upHole");
  const upQueueEl = document.getElementById("upQueue");

  const firebaseConfig = {
    apiKey: "AIzaSyD_uk47fURmQiHZnN8avfcGoNObMntdu_s",
    authDomain: "matsidewrestlingco-fb85f.firebaseapp.com",
    projectId: "matsidewrestlingco-fb85f",
    storageBucket: "matsidewrestlingco-fb85f.firebasestorage.app",
    messagingSenderId: "898197416726",
    appId: "1:898197416726:web:921ccbd0f63f7fd6537e37"
  };

  function initFirebaseIfNeeded() {
    if (!window.firebase) return;
    if (!firebase.apps || !firebase.apps.length) {
      firebase.initializeApp(firebaseConfig);
    }
    db = firebase.firestore();
  }

  function getQueryParams() {
    const params = new URLSearchParams(window.location.search || "");
    return {
      event: params.get("event"),
      mat: params.get("mat")
    };
  }

  function setMatFromParamsIfPresent() {
    const { mat } = getQueryParams();
    if (mat) {
      const matNum = parseInt(mat, 10);
      if (!Number.isNaN(matNum) && matNum >= 1 && matNum <= 12) {
        currentMat = matNum;
        if (matSelect) {
          matSelect.value = String(matNum);
        }
      }
    }
  }

  function formatMatchLine(m) {
    if (!m) return "—";
    const bout = m.bout != null ? `Bout ${m.bout}` : "";
    const wt   = m.weight ? ` ${m.weight}` : "";
    const red  = m.red && m.red.name ? m.red.name : "Red";
    const green= m.green && m.green.name ? m.green.name : "Green";
    const round= m.round ? ` • ${m.round}` : "";
    return `${bout}${wt} — ${red} vs ${green}${round}`;
  }

  function renderUpcomingFromList(list) {
    if (!Array.isArray(list)) list = [];
    const now  = list[0] || null;
    const deck = list[1] || null;
    const hole = list[2] || null;
    const tail = list.slice(3);

    if (upNowEl)  upNowEl.textContent  = formatMatchLine(now);
    if (upDeckEl) upDeckEl.textContent = formatMatchLine(deck);
    if (upHoleEl) upHoleEl.textContent = formatMatchLine(hole);

    if (upQueueEl) {
      if (!tail.length) {
        upQueueEl.textContent = "—";
      } else {
        const labels = tail
          .map(m => (m.bout != null ? `#${m.bout}` : ""))
          .filter(Boolean);
        upQueueEl.textContent = labels.length
          ? labels.join(", ")
          : `${tail.length} more`;
      }
    }

    // store current "Now" doc for completion
    window._currentMatchDocForMat = now || null;
  }

  function subscribeToMatchesForMat(eventId, matNumber) {
    if (!db || !eventId || !matNumber) return;
    if (unsubscribeMatches) {
      unsubscribeMatches();
      unsubscribeMatches = null;
    }

    const matchesRef = db
      .collection("events")
      .doc(eventId)
      .collection("matches");

    unsubscribeMatches = matchesRef
      .where("assignedMat","==", matNumber)
      .where("completed","==", false)
      .orderBy("queueIndex","asc")
      .orderBy("bout","asc")
      .onSnapshot(snapshot => {
        const upcoming = [];
        snapshot.forEach(doc => upcoming.push({ id: doc.id, ...doc.data() }));
        renderUpcomingFromList(upcoming);
      }, err => {
        console.error("Error subscribing to matches", err);
      });
  }

  function applyMatCountFromEventDoc(ev) {
    if (!ev || !matSelect) return;
    const matsCount = ev.mats || ev.matCount || 4;
    const prev = matSelect.value || "1";
    matSelect.innerHTML = "";
    for (let m = 1; m <= matsCount; m++) {
      const opt = document.createElement("option");
      opt.value = String(m);
      opt.textContent = `Mat ${m}`;
      matSelect.appendChild(opt);
    }
    const prevNum = parseInt(prev, 10);
    if (!Number.isNaN(prevNum) && prevNum >= 1 && prevNum <= matsCount) {
      matSelect.value = String(prevNum);
      currentMat = prevNum;
    } else {
      currentMat = 1;
      matSelect.value = "1";
    }
  }

  function resolveEventAndSubscribe() {
    if (!window.firebase) {
      console.warn("Firebase SDK not loaded; upcoming card inactive.");
      return;
    }
    initFirebaseIfNeeded();

    const { event } = getQueryParams();
    if (event) {
      currentEventId = event;
      db.collection("events").doc(event).get()
        .then(doc => {
          if (doc.exists) {
            applyMatCountFromEventDoc(doc.data());
          }
          subscribeToMatchesForMat(currentEventId, currentMat);
        })
        .catch(err => {
          console.error("Error loading event doc", err);
          subscribeToMatchesForMat(currentEventId, currentMat);
        });
      return;
    }

    // Fallback: use active event
    db.collection("events")
      .where("isActive","==", true)
      .limit(1)
      .get()
      .then(snap => {
        if (snap.empty) {
          console.warn("No active event found; upcoming card will show placeholders.");
          renderUpcomingFromList([]);
          return;
        }
        const doc = snap.docs[0];
        currentEventId = doc.id;
        applyMatCountFromEventDoc(doc.data());
        subscribeToMatchesForMat(currentEventId, currentMat);
      })
      .catch(err => {
        console.error("Error resolving active event", err);
      });
  }

  const SEGMENTS = {
    REG1:{ id:"REG1", period:1, time:60 },
    REG2:{ id:"REG2", period:2, time:90 },
    REG3:{ id:"REG3", period:3, time:120 },
    OT:  { id:"OT",   period:4, time:60 },
    TB1: { id:"TB1",  period:5, time:30 },
    TB2: { id:"TB2",  period:6, time:30 },
    UT:  { id:"UT",   period:7, time:30 }
  };

  function formatTime(sec) {
    const s = Math.max(0, Math.floor(sec));
    const m = Math.floor(s / 60);
    const r = s % 60;
    return String(m).padStart(2,"0") + ":" + String(r).padStart(2,"0");
  }

  function prettySegment(seg) {
    if (!seg) return "";
    if (seg.startsWith("REG")) return seg.replace("REG","");
    if (seg.startsWith("OT"))  return "OT";
    if (seg.startsWith("TB"))  return seg.toUpperCase();
    if (seg.startsWith("UT"))  return "UT";
    return seg;
  }

  function getMatState() {
    return mats[String(currentMat)] || {
      running:false,
      timeRemaining:60,
      period:1,
      red:0,
      green:0,
      segmentId:"REG1",
      timeline:[]
    };
  }

  function renderSummary() {
    const s = getMatState();
    // These were used by the old summary card. We guard them now in case
    // elements don't exist.
    const sumMatEl   = document.getElementById("sumMat");
    const sumSegEl   = document.getElementById("sumSeg");
    const sumTimeEl  = document.getElementById("sumTime");
    const sumRedEl   = document.getElementById("sumRed");
    const sumGreenEl = document.getElementById("sumGreen");

    if (sumMatEl)   sumMatEl.textContent   = currentMat;
    if (sumSegEl)   sumSegEl.textContent   = s.period || 1;
    if (sumTimeEl)  sumTimeEl.textContent  = formatTime(s.timeRemaining ?? 60);
    if (sumRedEl)   sumRedEl.textContent   = s.red ?? 0;
    if (sumGreenEl) sumGreenEl.textContent = s.green ?? 0;

    clockDisplay.textContent   = formatTime(s.timeRemaining ?? 60);
    segDisplay.textContent     = s.segmentId || "REG1";

    redScoreDisplay.textContent   = s.red ?? 0;
    greenScoreDisplay.textContent = s.green ?? 0;
  }

  function renderTimeline(){
    if(!timelineStream) return;
    const m = getMatState();
    const list = (m && Array.isArray(m.timeline)) ? m.timeline.slice() : [];
    list.sort((a,b)=>(a.ts||0)-(b.ts||0));

    timelineStream.innerHTML = "";
    list.forEach(item=>{
      const row = document.createElement("div");
      row.className = "tl-item";

      const time = document.createElement("div");
      time.className = "tl-time";
      const t = new Date(item.ts || Date.now());
      time.textContent = t.toLocaleTimeString([], {hour:"2-digit", minute:"2-digit"});

      const text = document.createElement("div");
      text.className = "tl-text";
      text.textContent = item.text || "";

      row.appendChild(time);
      row.appendChild(text);
      timelineStream.appendChild(row);
    });
    timelineStream.scrollTop = timelineStream.scrollHeight;
  }

  function appendTimelineEntry(entry){
    const m = getMatState() || {};
    const existing = Array.isArray(m.timeline) ? m.timeline.slice() : [];
    const now = Date.now();
    let normalized;
    if(typeof entry === "string"){
      normalized = { text:entry, ts:now };
    }else{
      normalized = Object.assign({ ts:now }, entry || {});
    }
    existing.push(normalized);
    socket.emit("updateState",{
      mat:currentMat,
      updates:{ timeline:existing }
    });
  }

  function showToast(msg){
    if(!toastEl) return;
    toastTextEl.textContent = msg || "Saved";
    toastEl.classList.add("show");
    setTimeout(()=>toastEl.classList.remove("show"), 1600);
  }

  // SOCKET HANDLERS

  socket.on("connect",()=>{
    connEl.textContent = "connected";
    connPill.classList.add("connected");
    socket.emit("registerDevice",{ type:"control", mat:currentMat });
  });

  socket.on("disconnect",()=>{
    connEl.textContent = "disconnected";
    connPill.classList.remove("connected");
  });

  socket.on("stateUpdate",(payload)=>{
    if(payload && payload.mats){
      mats = payload.mats;
      renderSummary();
      renderTimeline();
    }
  });

  // MAT SELECT
  matSelect.addEventListener("change",()=>{
    currentMat = parseInt(matSelect.value || "1",10) || 1;
    renderSummary();
    renderTimeline();
    if (db && currentEventId) {
      subscribeToMatchesForMat(currentEventId, currentMat);
    }
  });

  // TIMER
  document.getElementById("startBtn").addEventListener("click",()=>{
    socket.emit("updateState",{ mat:currentMat, updates:{ running:true }});
  });
  document.getElementById("stopBtn").addEventListener("click",()=>{
    socket.emit("updateState",{ mat:currentMat, updates:{ running:false }});
  });
  document.getElementById("resetTimerBtn").addEventListener("click",()=>{
    const s = getMatState();
    const seg = SEGMENTS[s.segmentId || "REG1"] || SEGMENTS.REG1;
    socket.emit("updateState",{
      mat:currentMat,
      updates:{ timeRemaining:seg.time, running:false }
    });
  });

  runningToggle.addEventListener("change",()=>{
    socket.emit("updateState",{
      mat:currentMat,
      updates:{ running:runningToggle.checked }
    });
  });

  // SEGMENTS
  document.querySelectorAll(".seg-pill").forEach(btn=>{
    btn.addEventListener("click",()=>{
      const segId = btn.dataset.seg || "REG1";
      const seg = SEGMENTS[segId] || SEGMENTS.REG1;

      document.querySelectorAll(".seg-pill").forEach(b=>b.classList.remove("active"));
      btn.classList.add("active");

      socket.emit("updateState",{
        mat:currentMat,
        updates:{
          segmentId:segId,
          period:seg.period,
          timeRemaining:seg.time
        }
      });
    });
  });

  // JOG BUTTONS
  document.querySelectorAll("[data-jog]").forEach(btn=>{
    btn.addEventListener("click",()=>{
      const delta = parseInt(btn.dataset.jog || "0",10);
      const s = getMatState();
      const cur = s.timeRemaining ?? 60;
      const next = Math.max(0, cur + delta);
      socket.emit("updateState",{ mat:currentMat, updates:{ timeRemaining:next }});
    });
  });

  // SCORE BUTTONS (now your wrestling actions)
  document.querySelectorAll("[data-score]").forEach(btn=>{
    btn.addEventListener("click",()=>{
      const who = btn.dataset.score;
      const pts = parseInt(btn.dataset.pts || "0",10);
      if(!who || !pts) {
        // allow -1 as valid
        if (!who) return;
      }
      const s = getMatState();
      const cur = (s[who] || 0) + pts;
      const clamped = Math.max(0, cur);
      socket.emit("updateState",{
        mat:currentMat,
        updates:{ [who]:clamped }
      });

      const label = who === "red" ? "Red" : "Green";
      const desc = pts > 0 ? `+${pts}` : `${pts}`;
      appendTimelineEntry(`${label} score change ${desc}`);
    });
  });

  // NAME INPUTS
  redNameInput.addEventListener("input",()=>{
    redNameLabel.textContent = redNameInput.value.trim() || "Red";
  });
  greenNameInput.addEventListener("input",()=>{
    greenNameLabel.textContent = greenNameInput.value.trim() || "Green";
  });

  // MATCH MODAL LOGIC
  const matchModalBackdrop = document.getElementById("matchModalBackdrop");
  const winnerRedBtn   = document.getElementById("winnerRedBtn");
  const winnerGreenBtn = document.getElementById("winnerGreenBtn");
  const methodButtons  = document.querySelectorAll(".method-grid .pill-btn-fat");
  const cancelMatchBtn = document.getElementById("cancelMatchBtn");
  const confirmMatchBtn= document.getElementById("confirmMatchBtn");
  const suggestLineEl  = document.getElementById("suggestLine");

  let selectedWinner = null;
  let selectedMethod = "decision";

  function openMatchModal(){
    selectedWinner = null;
    selectedMethod = "decision";
    winnerRedBtn.classList.remove("active");
    winnerGreenBtn.classList.remove("active");
    methodButtons.forEach(b=>b.classList.remove("active"));
    methodButtons[0].classList.add("active");

    const m = getMatState() || {};
    const red   = m.red || 0;
    const green = m.green || 0;
    let suggestion = "Pick winner & method.";
    if(red>green) suggestion = `Suggest: RED wins (${red}–${green})`;
    else if(green>red) suggestion = `Suggest: GREEN wins (${green}–${red})`;
    suggestLineEl.textContent = suggestion;

    matchModalBackdrop.classList.add("show");
  }

  function closeMatchModal(){
    matchModalBackdrop.classList.remove("show");
  }

  document.getElementById("endMatchBtn").addEventListener("click",openMatchModal);
  cancelMatchBtn.addEventListener("click",closeMatchModal);

  winnerRedBtn.addEventListener("click",()=>{
    selectedWinner = "red";
    winnerRedBtn.classList.add("active");
    winnerGreenBtn.classList.remove("active");
  });

  winnerGreenBtn.addEventListener("click",()=>{
    selectedWinner = "green";
    winnerGreenBtn.classList.add("active");
    winnerRedBtn.classList.remove("active");
  });

  methodButtons.forEach(btn=>{
    btn.addEventListener("click",()=>{
      methodButtons.forEach(b=>b.classList.remove("active"));
      btn.classList.add("active");
      selectedMethod = btn.dataset.method || "decision";
    });
  });

  confirmMatchBtn.addEventListener("click",()=>{
    const m = getMatState() || {};
    const red   = m.red || 0;
    const green = m.green || 0;
    const segment = m.segmentId || ("REG" + (m.period || 1));

    if(!selectedWinner){
      if(red > green) selectedWinner = "red";
      else if(green > red) selectedWinner = "green";
    }

    if(!selectedWinner){
      showToast("Please choose a winner");
      return;
    }

    const payload = {
      mat:currentMat,
      winner:selectedWinner,
      method:selectedMethod,
      redScore:red,
      greenScore:green,
      segmentId:segment,
      ts:Date.now()
    };

    socket.emit("matchEnded", payload);

    appendTimelineEntry({
      kind:"match",
      text:`Match ended: ${selectedWinner.toUpperCase()} by ${selectedMethod.replace("_"," ")} (${red}–${green})`
    });

    const winnerName =
      selectedWinner === "red"
        ? (redNameInput.value.trim() || "Red wrestler")
        : (greenNameInput.value.trim() || "Green wrestler");

    lastMatchMainEl.textContent =
      `${winnerName} wins by ${selectedMethod.replace("_"," ")} (${red}–${green})`;

    lastMatchMetaEl.textContent =
      `Mat ${currentMat}, Segment ${prettySegment(segment)} — ${
        new Date().toLocaleTimeString([], {hour:"2-digit", minute:"2-digit", second:"2-digit"})
      }`;

    const now = Date.now();
    const current = getMatState() || {};
    const existing = Array.isArray(current.timeline) ? current.timeline.slice() : [];
    const resetUpdates = {
      period:1,
      timeRemaining:60,
      running:false,
      red:0,
      green:0,
      timeline:[
        ...existing,
        { text:"Mat auto-reset after match submission.", ts:now, kind:"reset" }
      ]
    };
    socket.emit("updateState",{ mat:currentMat, updates:resetUpdates });

    try {
      if (db && currentEventId && window._currentMatchDocForMat && window._currentMatchDocForMat.id) {
        const matchId = window._currentMatchDocForMat.id;
        db.collection("events")
          .doc(currentEventId)
          .collection("matches")
          .doc(matchId)
          .set({
            completed: true,
            result: {
              winner: selectedWinner,
              method: selectedMethod,
              redScore: red,
              greenScore: green,
              endedAt: firebase.firestore.FieldValue.serverTimestamp()
            }
          }, { merge: true })
          .catch(err => console.error("Error updating match completion", err));
      }
    } catch (e) {
      console.error("Firestore completion error", e);
    }

    closeMatchModal();
    showToast("Match submitted & mat reset");
  });

  // PARAMS / INIT
  setMatFromParamsIfPresent();
  resolveEventAndSubscribe();

  // KEYBOARD SHORTCUTS
  document.addEventListener("keydown",(ev)=>{
    const key = ev.key;
    const tag = (ev.target && ev.target.tagName) || "";
    if(tag === "INPUT" || tag === "TEXTAREA") return;

    const mat = currentMat;

    // TIMER
    if (key === " ") {
      ev.preventDefault();
      const state = getMatState() || {};
      if (state.running) {
        socket.emit("updateState",{ mat, updates:{ running:false }});
      } else {
        socket.emit("updateState",{ mat, updates:{ running:true }});
      }
      return;
    }

    if (key === "r" || key === "R") {
      document.getElementById("resetTimerBtn").click();
      return;
    }

    if (key === "e" || key === "E") {
      openMatchModal();
      return;
    }

    // RED SCORING
    if (key === "1") socket.emit("addPoints", { mat, color: "red", pts: 1 });
    if (key === "2") socket.emit("addPoints", { mat, color: "red", pts: 2 });
    if (key === "3") socket.emit("addPoints", { mat, color: "red", pts: 3 });
    if (key === "4") socket.emit("addPoints", { mat, color: "red", pts: 2 }); // NF2
    if (key === "5") socket.emit("addPoints", { mat, color: "red", pts: 3 }); // NF3

    // GREEN SCORING
    if (key === "7") socket.emit("addPoints", { mat, color: "green", pts: 1 });
    if (key === "8") socket.emit("addPoints", { mat, color: "green", pts: 2 });
    if (key === "9") socket.emit("addPoints", { mat, color: "green", pts: 3 });
    if (key === "0") socket.emit("addPoints", { mat, color: "green", pts: 2 }); // NF2
    if (key === "-") socket.emit("addPoints", { mat, color: "green", pts: 3 }); // NF3
  });
</script>

</body>
</html>
