<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Matside — Control Panel v4.1</title>

<style>
  :root {
    --bg: #05060a;
    --panel: #11131b;
    --panel-soft: #141824;
    --muted: #9aa0a6;
    --accent: #1e88e5;
    --accent-soft: rgba(30,136,229,0.22);
    --red: #d32f2f;
    --green: #388e3c;
    --gold: #fbc02d;
    --border: #252836;
    --radius: 14px;
    --gap: 14px;
  }

  * {
    box-sizing: border-box;
  }

  html, body {
    margin: 0;
    padding: 0;
    background: radial-gradient(circle at top, #151821 0, #05060a 55%);
    color: #fff;
    font-family: system-ui,-apple-system,"Segoe UI",Roboto,Arial;
  }

  /* HEADER */
  .header-bar {
    background: #05060a;
    border-bottom: 1px solid #12141c;
    box-shadow: 0 14px 40px rgba(0, 0, 0, .9);
  }
  .header-inner {
    max-width: 1100px;
    margin: 0 auto;
    padding: 6px 16px;
    display: flex;
    align-items: center;
    gap: 10px;
  }
  .brand-logo {
    height: 40px;
    border-radius: 10px;
  }
  .brand-title {
    font-size: 18px;
    font-weight: 700;
    letter-spacing: .04em;
  }
  .header-accent {
    height: 2px;
    background: linear-gradient(90deg,
      rgba(30,136,229,0.0),
      rgba(30,136,229,0.65),
      rgba(251,192,45,0.7),
      rgba(30,136,229,0.0)
    );
  }

  .wrap {
    max-width: 1100px;
    margin: 0 auto;
    padding: 14px 16px 60px;
  }

  /* TOP BAR / SUMMARY */
  .top-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 14px;
    margin-bottom: 10px;
  }

  .brand-mini {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .brand-mini img {
    height: 22px;
    border-radius: 6px;
  }
  .brand-mini-title {
    font-size: 14px;
    font-weight: 600;
    color: var(--muted);
  }

  .status {
    font-size: 13px;
    color: var(--muted);
  }

  select {
    padding: 8px 10px;
    border-radius: 10px;
    border: 1px solid #242733;
    background: #080a10;
    color: #fff;
    font-size: 14px;
  }

  .summary-card {
    margin-top: 6px;
    padding: 8px 12px;
    border-radius: 14px;
    background: radial-gradient(circle at top left,
      rgba(30,136,229,0.18),
      rgba(10,12,20,0.95));
    border: 1px solid rgba(255,255,255,0.05);
    box-shadow: 0 16px 40px rgba(0,0,0,.9);
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    justify-content: space-between;
  }
  .summary-item {
    font-size: 13px;
  }
  .summary-item strong {
    font-weight: 800;
  }
  .redText { color: var(--red); }
  .greenText { color: var(--green); }

  /* TIMER PULSE */
  @keyframes timerPulse {
    0% { opacity: 1; }
    50% { opacity: 0.55; }
    100% { opacity: 1; }
  }
  .timer-running {
    animation: timerPulse 1.1s infinite ease-in-out;
  }

  /* GRID LAYOUT */
  .grid {
    display: grid;
    grid-template-columns: 2fr 3fr;
    gap: var(--gap);
    margin-top: 14px;
  }
  @media (max-width: 900px) {
    .grid {
      grid-template-columns: 1fr;
    }
  }

  .card {
    background: radial-gradient(circle at top, #191d2a 0, #10131e 40%, #070813 100%);
    border-radius: var(--radius);
    padding: 12px;
    border: 1px solid rgba(255,255,255,0.06);
    box-shadow: 0 18px 50px rgba(0,0,0,.95);
  }
  .card h3 {
    margin: 0 0 6px 0;
    font-size: 15px;
    letter-spacing: .05em;
    text-transform: uppercase;
    color: #e3e7f1;
  }
  .card-sub {
    font-size: 11px;
    color: var(--muted);
    margin-bottom: 6px;
  }

  .row {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    align-items: center;
  }

  button {
    border: 0;
    border-radius: 999px;
    padding: 9px 14px;
    font-weight: 700;
    cursor: pointer;
    font-size: 14px;
  }

  .btn-wide {
    min-width: 118px;
    justify-content: center;
  }
  .small {
    padding: 6px 10px;
    font-size: 12px;
  }

  .blue {
    background: linear-gradient(135deg,#2196f3,#1976d2);
    color: #fff;
  }
  .gray {
    background: #2a2f3b;
    color: #fff;
  }
  .red {
    background: #d32f2f;
    color: #fff;
  }
  .green {
    background: #388e3c;
    color: #fff;
  }
  .gold {
    background: #fbc02d;
    color: #000;
  }

  .btn-ghost {
    background: transparent;
    border: 1px solid #303341;
    color: var(--muted);
  }

  /* TIMER CARD LAYOUT */
  .timer-layout {
    display: flex;
    flex-direction: column;
    gap: 10px;
  }
  .timer-row-main {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 10px;
  }
  .timer-button-group {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
  }
  .timer-preset-row {
    display: flex;
    gap: 6px;
    flex-wrap: wrap;
    align-items: center;
    justify-content: space-between;
  }
  .pill-btn {
    padding: 6px 10px;
    border-radius: 999px;
    border: 1px solid rgba(255,255,255,0.12);
    background: rgba(12,15,25,0.9);
    color: #e0e3f0;
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: .09em;
    cursor: pointer;
  }
  .pill-btn.active {
    border-color: var(--accent);
    background: rgba(30,136,229,0.16);
    color: #eaf3ff;
  }

  .hint {
    font-size: 11px;
    color: var(--muted);
    margin-top: 4px;
  }

  .field-row {
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .field-row label {
    font-size: 11px;
    color: var(--muted);
  }
  input[type="text"] {
    padding: 6px 8px;
    border-radius: 8px;
    border: 1px solid #262a36;
    background: #060812;
    color: #fff;
    font-size: 13px;
  }

  /* SCORING */
  .score-columns {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
  }
  @media (max-width: 600px) {
    .score-columns {
      grid-template-columns: 1fr;
    }
  }
  .scoring-grid {
    display: grid;
    grid-template-columns: repeat(3, minmax(0,1fr));
    gap: 6px;
  }
  @media (max-width: 450px) {
    .scoring-grid {
      grid-template-columns: repeat(2, minmax(0,1fr));
    }
  }

  /* LAST MATCH */
  .last-match-main {
    font-weight: 600;
    font-size: 13px;
    margin-bottom: 4px;
  }
  .last-match-meta {
    font-size: 11px;
    color: var(--muted);
  }

  /* TIMELINE — NEW GLASS STYLE, FULL-WIDTH AT BOTTOM */
  .timeline-bar{
    margin-top:16px;
    background:linear-gradient(135deg, rgba(15,17,25,0.98), rgba(10,12,20,0.96));
    border-radius:18px;
    padding:12px 14px 14px;
    border:1px solid rgba(255,255,255,0.08);
    box-shadow:0 14px 36px rgba(0,0,0,.85);
  }
  .timeline-header{
    display:flex;
    align-items:center;
    justify-content:space-between;
    margin-bottom:8px;
  }
  .timeline-title{
    font-size:14px;
    font-weight:700;
    text-transform:uppercase;
    letter-spacing:.12em;
    color:var(--muted);
  }
  .timeline-hint{
    font-size:11px;
    color:var(--muted);
    opacity:0.9;
  }
  #timelineStream{
    display:flex;
    flex-wrap:wrap;
    gap:10px;
    max-height:260px;
    overflow-y:auto;
    padding:6px 2px 2px 2px;
  }
  .timeline-card{
    position:relative;
    flex:0 0 auto;
    min-width:190px;
    max-width:260px;
    background:rgba(8,10,18,0.9);
    border-radius:14px;
    padding:8px 10px;
    border:1px solid rgba(255,255,255,0.10);
    box-shadow:0 10px 26px rgba(0,0,0,.9);
    font-size:12px;
    backdrop-filter:blur(12px);
  }
  .timeline-card::before{
    content:"";
    position:absolute;
    inset:0;
    border-radius:inherit;
    pointer-events:none;
    border:1px solid rgba(255,255,255,0.06);
    opacity:0.7;
  }
  .timeline-card.tl-score-red{
    border-color:rgba(211,47,47,0.7);
    box-shadow:0 0 18px rgba(211,47,47,0.6);
  }
  .timeline-card.tl-score-green{
    border-color:rgba(56,142,60,0.7);
    box-shadow:0 0 18px rgba(56,142,60,0.6);
  }
  .timeline-card.tl-period{
    border-color:rgba(251,192,45,0.7);
    box-shadow:0 0 16px rgba(251,192,45,0.6);
  }
  .timeline-card.tl-match{
    border-color:rgba(30,136,229,0.75);
    box-shadow:0 0 20px rgba(30,136,229,0.7);
  }
  .timeline-card.tl-reset{
    border-color:rgba(144,164,174,0.8);
    box-shadow:0 0 16px rgba(144,164,174,0.6);
  }
  .tl-type{
    font-size:11px;
    text-transform:uppercase;
    letter-spacing:.10em;
    color:var(--muted);
    margin-bottom:2px;
  }
  .tl-body{
    font-size:13px;
    font-weight:500;
    margin-bottom:3px;
  }
  .tl-time{
    font-size:11px;
    color:var(--muted);
  }
  .timeline-empty{
    font-size:12px;
    color:var(--muted);
    opacity:0.85;
    padding:4px 2px;
  }

  /* TOAST */
  #toast{
    position:fixed;
    left:50%;
    bottom:10px;
    transform:translateX(-50%);
    padding:8px 14px;
    border-radius:999px;
    background:rgba(8,10,18,0.95);
    border:1px solid rgba(255,255,255,0.12);
    box-shadow:0 18px 40px rgba(0,0,0,.95);
    font-size:12px;
    display:none;
    align-items:center;
    gap:6px;
    z-index:9999;
  }
  #toastIcon{
    font-size:14px;
  }

  /* MATCH MODAL */
  #matchModalBackdrop{
    position:fixed;
    inset:0;
    background:rgba(0,0,0,0.7);
    display:none;
    align-items:center;
    justify-content:center;
    z-index:9998;
  }
  .modal{
    background:#10121a;
    border-radius:16px;
    padding:14px 16px;
    max-width:420px;
    width:100%;
    border:1px solid rgba(255,255,255,0.16);
    box-shadow:0 22px 60px rgba(0,0,0,.98);
  }
  .modal h3{
    margin:0 0 8px 0;
    font-size:16px;
  }
  .modal-section{
    margin-top:8px;
    padding-top:6px;
    border-top:1px solid #24293a;
  }
  .suggest-line{
    font-size:12px;
    color:var(--muted);
    margin-bottom:6px;
  }
  .pill-row{
    display:flex;
    flex-wrap:wrap;
    gap:6px;
  }
  .pill-btn-fat{
    border-radius:999px;
    border:1px solid #303548;
    padding:6px 10px;
    background:#0c101c;
    font-size:12px;
    cursor:pointer;
  }
  .pill-btn-fat.active{
    border-color:var(--accent);
    background:rgba(30,136,229,0.3);
  }
  .modal-footer{
    display:flex;
    justify-content:space-between;
    gap:8px;
    margin-top:10px;
  }

  /* VERSION TAG */
  #version-tag{
    position:fixed;
    bottom:6px;
    right:10px;
    font-size:11px;
    color:#666;
    opacity:0.75;
    pointer-events:none;
    user-select:none;
    font-weight:600;
    z-index:99999;
  }

/* ============================================================
   END MATCH MODAL — RESTORE BUTTON COLORS
   ============================================================ */

.modal-container button {
  font-weight: 600;
  border-radius: 14px;
  padding: 8px 18px;
  border: none;
  cursor: pointer;
  transition: 0.2s ease;
}

/* Winner buttons */
#winnerRedBtn {
  background: #c62828 !important;
  color: white !important;
}
#winnerGreenBtn {
  background: #2e7d32 !important;
  color: white !important;
}

/* Winner active state (when selected in JS) */
.pill-btn-fat.active,
.pill-btn-fat.selected {
  outline: 2px solid #4c89ff;
}

/* Method buttons (default) */
.pill-btn-fat {
  background: #2f3640 !important;
  color: #eee !important;
}

/* Method selected */
.pill-btn-fat[data-method].active,
.pill-btn-fat[data-method].selected {
  background: #4c89ff !important;
  color: white !important;
}

/* Submit button */
button.gold {
  background: #f4c542 !important;
  color: black !important;
}
button.gold:hover {
  opacity: 0.9;
}

/* Cancel button */
button.gray {
  background: #555 !important;
  color: white !important;
}
button.gray:hover {
  opacity: 0.8;
}
  
</style>
</head>
<body>

<div class="header-bar">
  <div class="header-inner">
    <img src="https://www.matside.org/assets/images/image01.png" class="brand-logo" alt="Matside logo"/>
    <div class="brand-title">Matside Control Hub</div>
  </div>
  <div class="header-accent"></div>
</div>

<div class="wrap">

  <!-- TOP BAR -->
  <div class="top-row">
    <div class="brand-mini">
      <img src="https://www.matside.org/assets/images/image01.png" alt="Matside mini"/>
      <div class="brand-mini-title">Control Panel</div>
    </div>

    <div style="display:flex;align-items:center;gap:12px;">
      <div>
        <label style="font-size:12px;">Select</label><br/>
        <select id="matSelect">
          <option value="1">Mat 1</option>
          <option value="2">Mat 2</option>
          <option value="3">Mat 3</option>
          <option value="4">Mat 4</option>
        </select>
      </div>
      <div class="status">
        Status: <span id="conn">connecting…</span>
      </div>
    </div>
  </div>

  <!-- SUMMARY -->
  <div class="summary-card">
    <div class="summary-item">Mat: <strong id="sumMat">1</strong></div>
    <div class="summary-item">Period: <strong id="sumSeg">1</strong></div>
    <div class="summary-item">Time: <strong id="sumTime">01:00</strong></div>
    <div class="summary-item">Red: <strong id="sumRed" class="redText">0</strong></div>
    <div class="summary-item">Green: <strong id="sumGreen" class="greenText">0</strong></div>
  </div>

  <!-- MAIN GRID -->
  <div class="grid">

    <!-- LEFT COLUMN -->
    <div>

      <!-- TIMER CARD -->
      <div class="card">
        <h3>Timer</h3>
        <div class="card-sub">
          Control the clock and choose regulation or overtime segments.
        </div>

        <div class="timer-layout">

          <!-- Start / Stop / End Match -->
          <div class="timer-row-main">
            <div class="timer-button-group">
              <button id="startBtn" class="blue btn-wide">Start</button>
              <button id="stopBtn" class="gray btn-wide">Stop</button>
              <button id="endMatchBtn" class="gold btn-wide">End Match</button>
            </div>
          </div>

          <!-- Reset timer + segment presets -->
          <div class="timer-preset-row">
            <button id="resetTimerBtn" class="btn-ghost small">Reset Timer</button>
            <div class="field-row">
              <label>Reg:</label>
              <button class="pill-btn" data-seg="REG1">1:00</button>
              <button class="pill-btn" data-seg="REG2">1:30</button>
              <button class="pill-btn" data-seg="REG3">2:00</button>
            </div>
          </div>

          <!-- Overtime row -->
          <div class="timer-preset-row">
            <div class="field-row">
              <label>OT Series:</label>
              <button class="pill-btn" data-seg="OT">OT 1:00</button>
              <button class="pill-btn" data-seg="TB1">TB1 0:30</button>
              <button class="pill-btn" data-seg="TB2">TB2 0:30</button>
              <button class="pill-btn" data-seg="UT">UT 0:30</button>
            </div>
          </div>

          <!-- Custom time -->
          <div class="timer-preset-row">
            <div class="field-row" style="flex:1;">
              <label>Custom (MM:SS or seconds):</label>
              <input id="customTimeInput" type="text" placeholder="1:15 or 75"/>
              <button id="applyCustomTimeBtn" class="pill-btn small">Apply</button>
            </div>
          </div>

          <div class="hint">
            Timer displays live in the top summary and on scoreboards. Active segment is highlighted.
          </div>
        </div>
      </div>

      <!-- RESET CARD -->
      <div class="card" style="margin-top:var(--gap);">
        <h3>Reset Mat</h3>
        <button id="resetMatBtn" class="red btn-wide">Reset Entire Mat</button>
        <div class="hint">
          Resets period to P1, time to 1:00, scores to 0, clears names, and wipes the timeline.
        </div>
      </div>
    </div>

    <!-- RIGHT COLUMN -->
    <div>

      <!-- SCORING CARD -->
      <div class="card">
        <h3>Scoring</h3>
        <div class="card-sub">Tap buttons for common wrestling scores.</div>

        <div class="score-columns">

          <!-- RED SCORING -->
          <div>
            <div class="status" style="margin-bottom:4px;">Red Wrestler</div>
            <div class="scoring-grid">
              <button class="red small" data-color="red" data-pts="1">E1 (+1)</button>
              <button class="red small" data-color="red" data-pts="2">R2 (+2)</button>
              <button class="red small" data-color="red" data-pts="3">T3 (+3)</button>
              <button class="red small" data-color="red" data-pts="2">N2 (+2)</button>
              <button class="red small" data-color="red" data-pts="3">N3 (+3)</button>
              <button class="red small" data-color="red" data-pts="4">N4 (+4)</button>
            </div>
          </div>

          <!-- GREEN SCORING -->
          <div>
            <div class="status" style="margin-bottom:4px;">Green Wrestler</div>
            <div class="scoring-grid">
              <button class="green small" data-color="green" data-pts="1">E1 (+1)</button>
              <button class="green small" data-color="green" data-pts="2">R2 (+2)</button>
              <button class="green small" data-color="green" data-pts="3">T3 (+3)</button>
              <button class="green small" data-color="green" data-pts="2">N2 (+2)</button>
              <button class="green small" data-color="green" data-pts="3">N3 (+3)</button>
              <button class="green small" data-color="green" data-pts="4">N4 (+4)</button>
            </div>
          </div>
        </div>

        <div class="row" style="margin-top:10px;justify-content:space-between;">
          <button id="subRed" class="small gray">-1 Red</button>
          <button id="resetScores" class="small gold">Reset Scores</button>
          <button id="subGreen" class="small gray">-1 Green</button>
        </div>
      </div>

      <!-- NAMES CARD -->
      <div class="card" style="margin-top:var(--gap);">
        <h3>Wrestler Names</h3>
        <div class="card-sub">Names are local-only for now; scoreboards can be wired later.</div>

        <div class="row" style="margin-bottom:8px;">
          <div style="flex:1;">
            <label style="font-size:12px;">Red Wrestler</label><br/>
            <input id="redNameInput" type="text" placeholder="Red wrestler name"/>
          </div>
          <div style="flex:1;">
            <label style="font-size:12px;">Green Wrestler</label><br/>
            <input id="greenNameInput" type="text" placeholder="Green wrestler name"/>
          </div>
        </div>
      </div>

      <!-- LAST MATCH CARD -->
      <div class="card" style="margin-top:var(--gap);">
        <h3>Last Match Result</h3>
        <div id="lastMatchMain" class="last-match-main">
          No match submitted yet.
        </div>
        <div id="lastMatchMeta" class="last-match-meta">
          —
        </div>
      </div>

    </div>
  </div>

  <!-- FULL-WIDTH HORIZONTAL TIMELINE (BOTTOM) -->
  <div class="timeline-bar">
    <div class="timeline-header">
  <div class="timeline-title">Timeline</div>

  <div style="display:flex;align-items:center;gap:10px;">
    <button id="resetTimelineBtn" class="btn-ghost small" style="
      padding:4px 10px;
      border-radius:8px;
      font-size:11px;
    ">Reset Timeline</button>

    <div class="timeline-hint">Live event stream for this mat.</div>
  </div>
</div>
    <div id="timelineStream"></div>
  </div>

</div>

<!-- MATCH MODAL -->
<div id="matchModalBackdrop">
  <div class="modal">
    <h3>End Match</h3>

    <div class="modal-section">
      <h4 style="margin:0 0 4px 0;font-size:13px;">Suggested</h4>
      <div id="suggestLine" class="suggest-line">—</div>
    </div>

    <div class="modal-section">
      <h4 style="margin:0 0 4px 0;font-size:13px;">Winner</h4>
      <div class="pill-row">
        <button id="winnerRedBtn"   class="pill-btn-fat">Red</button>
        <button id="winnerGreenBtn" class="pill-btn-fat">Green</button>
      </div>
    </div>

    <div class="modal-section">
      <h4 style="margin:0 0 4px 0;font-size:13px;">Method</h4>
      <div class="pill-row">
        <button class="pill-btn-fat" data-method="decision">Decision</button>
        <button class="pill-btn-fat" data-method="tech_fall">Tech Fall</button>
        <button class="pill-btn-fat" data-method="pin">Pin</button>
        <button class="pill-btn-fat" data-method="forfeit">Forfeit</button>
      </div>
    </div>

    <div class="modal-footer">
      <button id="cancelMatchBtn" class="gray small" style="flex:1;">Cancel</button>
      <button id="confirmMatchBtn" class="gold small" style="flex:1;">Submit</button>
    </div>
  </div>
</div>

<!-- TOAST -->
<div id="toast">
  <span id="toastIcon">✓</span>
  <span id="toastText">Saved</span>
</div>

<div id="version-tag">v4.1</div>

<!-- Socket.IO -->
<script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>

<script>
  const SERVER_URL = "https://scoreboard-server-er33.onrender.com";
  const socket = io(SERVER_URL, { transports:["websocket","polling"] });

  let mats = {};
  let currentMat = 1;

  const matSelect   = document.getElementById("matSelect");
  const connEl      = document.getElementById("conn");
  const sumMatEl    = document.getElementById("sumMat");
  const sumSegEl    = document.getElementById("sumSeg");
  const sumTimeEl   = document.getElementById("sumTime");
  const sumRedEl    = document.getElementById("sumRed");
  const sumGreenEl  = document.getElementById("sumGreen");

  const timelineStream   = document.getElementById("timelineStream");
  const toastEl          = document.getElementById("toast");
  const toastTextEl      = document.getElementById("toastText");

  const redNameInput     = document.getElementById("redNameInput");
  const greenNameInput   = document.getElementById("greenNameInput");
  const lastMatchMainEl  = document.getElementById("lastMatchMain");
  const lastMatchMetaEl  = document.getElementById("lastMatchMeta");

  const SEGMENTS = {
    REG1:{ id:"REG1", period:1, time:60 },
    REG2:{ id:"REG2", period:2, time:90 },
    REG3:{ id:"REG3", period:3, time:120 },
    OT:  { id:"OT",   period:4, time:60 },
    TB1: { id:"TB1",  period:5, time:30 },
    TB2: { id:"TB2",  period:6, time:30 },
    UT:  { id:"UT",   period:7, time:30 }
  };

  function formatTime(sec) {
    const s = Math.max(0, Math.floor(sec));
    const m = Math.floor(s / 60);
    const r = s % 60;
    return String(m).padStart(2,"0") + ":" + String(r).padStart(2,"0");
  }

  function prettySegment(seg) {
    if (!seg) return "";
    if (seg.startsWith("REG")) return seg.replace("REG","");
    if (seg.startsWith("OT"))  return "OT";
    if (seg.startsWith("TB"))  return seg.toUpperCase();
    if (seg.startsWith("UT"))  return "UT";
    return seg;
  }

  function getMatState() {
    return mats[currentMat] || null;
  }

  function renderSummary() {
    const m = getMatState();
    if (!m) return;
    sumMatEl.textContent   = String(currentMat);
    sumSegEl.textContent   = prettySegment(m.segmentId || ("REG" + (m.period || 1)));
    sumTimeEl.textContent  = formatTime(m.time ?? 0);
    sumRedEl.textContent   = String(m.red ?? 0);
    sumGreenEl.textContent = String(m.green ?? 0);

    if (m.running) {
      sumTimeEl.classList.add("timer-running");
    } else {
      sumTimeEl.classList.remove("timer-running");
    }
  }

  function appendTimelineEntry(entry){
    const m = getMatState() || {};
    const existing = Array.isArray(m.timeline) ? m.timeline.slice() : [];
    const now = Date.now();
    let normalized;
    if(typeof entry === "string"){
      normalized = { text:entry, ts:now };
    }else{
      normalized = Object.assign({ ts:now }, entry || {});
    }
    existing.push(normalized);
    socket.emit("updateState",{
      mat:currentMat,
      updates:{ timeline:existing }
    });
  }

  function renderTimeline(){
    if(!timelineStream) return;
    const m = getMatState();
    const list = (m && Array.isArray(m.timeline)) ? m.timeline : [];
    if(!list.length){
      timelineStream.innerHTML = `<div class="timeline-empty"><em>No events yet.</em></div>`;
      return;
    }

    timelineStream.innerHTML = list.map(item=>{
      let text = "";
      let ts   = Date.now();
      let kind = item && item.kind ? item.kind : null;
      let color = item && item.color ? item.color : null;

      if(typeof item === "string"){
        text = item;
      }else if(item && item.text){
        text = item.text;
        ts   = item.ts || ts;
      }else{
        text = String(item);
      }

      let type = "Event";
      const lower = text.toLowerCase();
      if(kind === "match" || lower.includes("match ended")) {
        type = "Match End";
      } else if(kind === "reset" || lower.includes("reset")) {
        type = "Reset";
      } else if(kind === "period" || lower.includes("period")) {
        type = "Period";
      } else if(kind === "score") {
        type = "Score";
      }

      let extraClass = "";
      if(kind === "score" && color === "red") {
        extraClass = " tl-score-red";
      } else if(kind === "score" && color === "green") {
        extraClass = " tl-score-green";
      } else if(kind === "period") {
        extraClass = " tl-period";
      } else if(kind === "match") {
        extraClass = " tl-match";
      } else if(kind === "reset") {
        extraClass = " tl-reset";
      } else if(lower.includes("red")) {
        extraClass = " tl-score-red";
      } else if(lower.includes("green")) {
        extraClass = " tl-score-green";
      }

      const t = new Date(ts).toLocaleTimeString([], {
        hour:"2-digit",
        minute:"2-digit",
        second:"2-digit"
      });

      return `
        <div class="timeline-card${extraClass}">
          <div class="tl-type">${type}</div>
          <div class="tl-body">${text}</div>
          <div class="tl-time">${t}</div>
        </div>
      `;
    }).join("");

    // auto-scroll to bottom as new events come in
    timelineStream.scrollTop = timelineStream.scrollHeight;
  }

  function showToast(message){
    toastTextEl.textContent = message;
    toastEl.style.display = "flex";
    setTimeout(()=>{ toastEl.style.display = "none"; }, 2500);
  }

  socket.on("connect",()=>{
    connEl.textContent = "connected";
    socket.emit("registerDevice",{ type:"control", mat:currentMat });
  });

  socket.on("disconnect",()=>{
    connEl.textContent = "disconnected";
  });

  socket.on("stateUpdate",(payload)=>{
    if(payload && payload.mats){
      mats = payload.mats;
      renderSummary();
      renderTimeline();
    }
  });

  // MAT SELECT
  matSelect.addEventListener("change",()=>{
    currentMat = parseInt(matSelect.value || "1",10) || 1;
    renderSummary();
    renderTimeline();
  });

  // TIMER
  document.getElementById("startBtn").addEventListener("click",()=>{
    socket.emit("updateState",{ mat:currentMat, updates:{ running:true }});
  });
  document.getElementById("stopBtn").addEventListener("click",()=>{
    socket.emit("updateState",{ mat:currentMat, updates:{ running:false }});
  });
  document.getElementById("resetTimerBtn").addEventListener("click",()=>{
    const m = getMatState() || {};
    const t = (typeof m.segmentDefaultTime === "number") ? m.segmentDefaultTime : 60;
    socket.emit("updateState",{ mat:currentMat, updates:{ time:t, running:false }});
    showToast("Timer reset");
  });

  // SCORING
  document.querySelectorAll("[data-color][data-pts]").forEach(btn=>{
    btn.addEventListener("click",()=>{
      const color = btn.getAttribute("data-color");
      const pts   = parseInt(btn.getAttribute("data-pts")||"0",10);
      if(!color || !pts) return;

      socket.emit("addPoints",{ mat:currentMat, color, pts });

      const who  = color === "red" ? "Red" : "Green";
      const label = (btn.textContent || "").trim() || `+${pts}`;
      appendTimelineEntry({
        kind:"score",
        color,
        text:`${who} +${pts} (${label})`
      });
    });
  });

  document.getElementById("subRed").addEventListener("click",()=>{
    socket.emit("subPoint",{ mat:currentMat, color:"red" });
    appendTimelineEntry({
      kind:"score",
      color:"red",
      text:"Red score corrected (-1)"
    });
  });
  document.getElementById("subGreen").addEventListener("click",()=>{
    socket.emit("subPoint",{ mat:currentMat, color:"green" });
    appendTimelineEntry({
      kind:"score",
      color:"green",
      text:"Green score corrected (-1)"
    });
  });

  document.getElementById("resetScores").addEventListener("click",()=>{
    socket.emit("updateState",{ mat:currentMat, updates:{ red:0, green:0 }});
    appendTimelineEntry({
      kind:"reset",
      text:"Scores reset to 0–0"
    });
  });

  // PERIOD PRESETS
  document.querySelectorAll(".pill-btn[data-seg]").forEach(btn=>{
    btn.addEventListener("click",()=>{
      const key = btn.getAttribute("data-seg");
      const seg = SEGMENTS[key];
      if(!seg) return;
      const updates = {
        segmentId:seg.id,
        period:seg.period,
        time:seg.time,
        segmentDefaultTime:seg.time,
        running:false
      };
      socket.emit("updateState",{ mat:currentMat, updates });
      const nice = prettySegment(seg.id);
      showToast(`Set segment: ${key}`);
      appendTimelineEntry({
        kind:"period",
        text:`Segment changed to ${nice}`
      });
    });
  });

  // CUSTOM TIME
  document.getElementById("applyCustomTimeBtn").addEventListener("click",()=>{
    const val = document.getElementById("customTimeInput").value.trim();
    if(!val) return;
    let seconds = 0;

    if(val.includes(":")){
      const parts = val.split(":");
      if(parts.length !== 2){
        showToast("Invalid format");
        return;
      }
      const mm = parseInt(parts[0],10);
      const ss = parseInt(parts[1],10);
      if(isNaN(mm)||isNaN(ss)||mm<0||ss<0||ss>=60){
        showToast("Invalid MM:SS");
        return;
      }
      seconds = mm*60 + ss;
    }else{
      const s = parseInt(val,10);
      if(isNaN(s)||s<0){
        showToast("Invalid seconds");
        return;
      }
      seconds = s;
    }

    socket.emit("updateState",{
      mat:currentMat,
      updates:{
        time:seconds,
        segmentDefaultTime:seconds,
        running:false
      }
    });
    const fmt = formatTime(seconds);
    showToast(`Custom time set: ${fmt}`);
    appendTimelineEntry({
      kind:"period",
      text:`Custom time set to ${fmt}`
    });
  });

  // RESET MAT
  document.getElementById("resetMatBtn").addEventListener("click",()=>{
    const updates = {
      period:1,
      segmentId:"REG1",
      time:60,
      segmentDefaultTime:60,
      running:false,
      red:0,
      green:0,
      timeline:[]
    };
    socket.emit("updateState",{ mat:currentMat, updates });
    redNameInput.value   = "";
    greenNameInput.value = "";
    showToast("Mat reset");
    appendTimelineEntry({
      kind:"reset",
      text:"Mat manually reset"
    });
  });

  // RESET TIMELINE ONLY
  document.getElementById("resetTimelineBtn").addEventListener("click", () => {
    const m = getMatState();
    const now = Date.now();

  socket.emit("updateState", {
    mat: currentMat,
    updates: {
      timeline: [
        { text: "Timeline manually cleared.", ts: now, kind: "reset" }
      ]
    }
  });

  showToast("Timeline cleared");
});
  
  // NAMES
  redNameInput.addEventListener("change",()=>{
    showToast("Red name updated (local only)");
  });
  greenNameInput.addEventListener("change",()=>{
    showToast("Green name updated (local only)");
  });

  // MATCH END MODAL
  const matchModalBackdrop = document.getElementById("matchModalBackdrop");
  const endMatchBtn        = document.getElementById("endMatchBtn");
  const cancelMatchBtn     = document.getElementById("cancelMatchBtn");
  const confirmMatchBtn    = document.getElementById("confirmMatchBtn");
  const winnerRedBtn       = document.getElementById("winnerRedBtn");
  const winnerGreenBtn     = document.getElementById("winnerGreenBtn");
  const methodButtons      = Array.from(document.querySelectorAll(".pill-btn-fat[data-method]"));
  const suggestLineEl      = document.getElementById("suggestLine");

  let selectedWinner = null;
  let selectedMethod = "decision";

  function openMatchModal(){
    const m = getMatState() || {};
    const red   = m.red || 0;
    const green = m.green || 0;
    const diff  = Math.abs(red - green);
    const segment = m.segmentId || ("REG" + (m.period || 1));

    let suggestion = `Current score: Red ${red} – Green ${green} (Segment ${prettySegment(segment)})`;

    if(red > green){
      suggestion += " • Red is currently leading.";
    }else if(green > red){
      suggestion += " • Green is currently leading.";
    }else{
      suggestion += " • Match is currently tied.";
    }

    if(suggestLineEl) suggestLineEl.textContent = suggestion;
    matchModalBackdrop.style.display = "flex";
  }

  function closeMatchModal(){
    matchModalBackdrop.style.display = "none";
  }

  endMatchBtn.addEventListener("click", openMatchModal);
  cancelMatchBtn.addEventListener("click", closeMatchModal);

  winnerRedBtn.addEventListener("click",()=>{
    selectedWinner = "red";
    winnerRedBtn.classList.add("active");
    winnerGreenBtn.classList.remove("active");
  });
  winnerGreenBtn.addEventListener("click",()=>{
    selectedWinner = "green";
    winnerGreenBtn.classList.add("active");
    winnerRedBtn.classList.remove("active");
  });

  methodButtons.forEach(btn=>{
    btn.addEventListener("click",()=>{
      methodButtons.forEach(b=>b.classList.remove("active"));
      btn.classList.add("active");
      selectedMethod = btn.dataset.method || "decision";
    });
  });

  confirmMatchBtn.addEventListener("click",()=>{
    const m = getMatState() || {};
    const red   = m.red || 0;
    const green = m.green || 0;
    const segment = m.segmentId || ("REG" + (m.period || 1));

    if(!selectedWinner){
      if(red > green) selectedWinner = "red";
      else if(green > red) selectedWinner = "green";
    }

    if(!selectedWinner){
      showToast("Please choose a winner");
      return;
    }

    const payload = {
      mat:currentMat,
      winner:selectedWinner,
      method:selectedMethod,
      redScore:red,
      greenScore:green,
      segmentId:segment,
      ts:Date.now()
    };

    socket.emit("matchEnded", payload);

    appendTimelineEntry({
      kind:"match",
      text:`Match ended: ${selectedWinner.toUpperCase()} by ${selectedMethod.replace("_"," ")} (${red}–${green})`
    });

    const winnerName =
      selectedWinner === "red"
        ? (redNameInput.value.trim() || "Red wrestler")
        : (greenNameInput.value.trim() || "Green wrestler");

    lastMatchMainEl.textContent =
      `${winnerName} wins by ${selectedMethod.replace("_"," ")} (${red}–${green})`;

    lastMatchMetaEl.textContent =
      `Mat ${currentMat}, Segment ${prettySegment(segment)} — ${new Date(payload.ts).toLocaleTimeString([], {hour:"2-digit", minute:"2-digit", second:"2-digit"})}`;

    const now = Date.now();
    const current = getMatState() || {};
    const existing = Array.isArray(current.timeline) ? current.timeline.slice() : [];
    const resetUpdates = {
      period:1,
      segmentId:"REG1",
      time:60,
      segmentDefaultTime:60,
      running:false,
      red:0,
      green:0,
      timeline:[
        ...existing,
        { text:"Mat auto-reset after match submission.", ts:now, kind:"reset" }
      ]
    };
    socket.emit("updateState",{ mat:currentMat, updates:resetUpdates });

    closeMatchModal();
    showToast("Match submitted & mat reset");
  });
</script>

</body>
</html>
